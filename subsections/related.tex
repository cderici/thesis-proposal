%\newpage

\section{Related Work}
\label{sec:related}

\paragraph{Higher-order dynamic VMs}
Dynamic VM implementations are becoming increasingly popular for their
rapid prototyping potential, as the effort required to implement a new
VM from scratch is often quite large. Therefore, instead of manually
implementing a VM in a low-level language such as C, it is often
argued that building on top of an existing object-oriented
general-purpose VMs or dynamic integration via generating a VM using a
"specification" of a language allows easier and more maintainable
implementations with competitive performance
\cite{bolz_how_no:07}. One of the major actors for the former approach
is the \emph{GraalVM}, which is a modified version of the Java HotSpot
VM on the JVM (Java Virtual Machine). GraalVM uses a language
implementation framework called Truffle, and a method-based JIT
compiler called Graal to implement VMs on the JVM for dynamic
languages such as Javascript, Ruby and Python \cite{graal:13}. As
opposed to building on top of VM, the \emph{RPython} project
introduced the idea of automatically generating a VM from a language
specification represented as an interpreter via meta-tracing
\cite{rpython07}. For example, as mentioned in the introduction, PyPy
is an implementation of Python that is built on the RPython
meta-tracing framework that generated a VM including a tracing JIT for
Python with a better performance than the CPython itself. In addition
to the RPython framework, there are other meta-tracing systems as
well, such as the SPUR, a tracing JIT compiler for CIL bytecode
\cite{miller2004common}, meta-tracing languages that are implemented
in C\# \cite{spur}.

\paragraph{Tracing JIT VMs}
Like PyPy, Pycket is built on the RPython meta-tracing framework as
well, and this study tries to identify approaches on achieving
efficient self-hosting on Pycket running a tracing JIT. Therefore it
would be relevant to mention here some notable tracing JIT VMs
too. Initially introduced by the Dynamo project \cite{dynamo},
trace-based compilation is successfully utilized by many VMs including
some commercial VMs such as Mozilla's TraceMonkey JavaScript VM
\cite{tracemonkey}, Adobe's Tamarin ActionScript VM \cite{tamarin}, as
well as some research VMs such as LuaJIT \cite{luajit:08}, Converge
\cite{converge:05}, Lambdamachine \cite{lambdamachine} and PyHaskell
\cite{pyhaskell}.

\paragraph{Optimizing VM performance in a meta-tracing context}
As we mentioned in \secref{subsec:rpython}, there are a lot of dynamic
optimizations performed by the RPython back-end that the interpreter
should be in sync with. There are two main approaches a VM author may
employ to optimize such a system: \textbf{i)} improve the interpreter
performance, \textbf{ii)} modify the interpreter to produce traces
that are more optimizable. Both of these approaches operate on the
interpreter, therefore the improvements should focus on the common
patterns that are specific to the language being interpreted. For
example, along with the general JIT improvements such as value
promotion and edlibale functions, PyPy and Converge both focus on
optimizing the objects, classes and modules \cite{bolz15-meta-vm}.

\paragraph{Self-hosting}
Additionally, Bolz and contributors state that in general-purpose VMs,
the compiler and the language being implemented should be semantically
in sync to achieve a good performance \cite{bolz_how_no:07,
  runtime-feedback:11}. As we discussed in
\secref{subsec:performance}, we study the relationship between the
semantics of the programs common to self-hosting and the interpreter
\& trace performance. Unfortunately, to the best of our knowledge, no
studies of self-hosting on meta-tracing has been done so far. However,
there are self-hosting VMs for dynamic languages, such as the Tachyon
VM for JavaScript, which is a bootstrapping JIT compiler that is
completely hand-coded in JavaScript and doesn't use any automatic
generation techniques \cite{self-hostJSvm:11}. Although Tachyon is
quite different than Pycket and bootstraps the VM itself, it uses
control-flow graphs in SSA form, similar to Pycket. Moreover, it uses
interesting techniques that might prove useful for Pycket as well,
such as conditional constant propogation via abstract interpretation
\cite{sccp:91}. Additionally, one of the major issues with
self-hosting is interpreting an interpreter-style dispatch loops with
complex control-flow paths. There are low-level techniques to deal
with such control-flow issues on VMs, such as indirect branch
prediction \cite{branch-predict:03}. However, in our case implementing
such techniques would require modifying the underlying RPython, where
our approach is at the language (interpreter) level.


Virtual machine showdown: Stack versus registers.

Another approach is to add support for dynamic languages to an
existing high-performance static-language VM \cite{stJITdyn:12,
  dynStatComp:12}.

\paragraph{Managing abstraction levels}
collapsing towers of interpreters \cite{collapse:17}

Hierarchical Layering of VMs \cite{layering:09}


\paragraph{heap allocated continuations}
asdasdasd \cite{whatever:19, compWithContLLVM:16}



% a head-to-head comparison difficult or impossible.

%% To the best of our knowledge, no comprehensive synthesis of issues and
%% opportunities has been done.




% since we are not able to

%% Bilmemne et al presents ..... In contrast to Pycket, in this system
%% ..... However, Pycket does not .....

%% \paragraph{just description}
%% Occurrence Typing Occurrence typing [43, 42] extends the type system
%% with a proposition environment that represents the information on the
%% types of bindings down conditional branches. These propositions are
%% then used to update the types associated with bindings in the type
%% environment down branches so binding occurrences are given different
%% types depending on the branches they appear in, and the conditionals
%% that lead to that branch.

% Notably, they further perform a qualitative analysis aiming to
% identify the reasons why

% There are other works that are relevant to our investigations of ....

% one sentence

% What's diff about TC from the related work
% small summary for diesel....
% - diesel supports x
%  - calculus supports some subset of x
% we support y, which covers most of x but also foo
